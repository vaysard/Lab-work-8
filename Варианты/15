# Определение лабиринта 5x5
# 0 - свободный путь, 1 - стена
MAZE = [
    [0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

MAZE_SIZE = len(MAZE) # Размер лабиринта (в данном случае 5)

# Начальная точка (строка, столбец)
START_POINT = (0, 0)
# Конечная точка (строка, столбец)
END_POINT = (MAZE_SIZE - 1, MAZE_SIZE - 1) # В данном случае (4, 4)

def find_all_paths_in_maze(maze, start, end):
    """
    Находит все возможные пути от начальной до конечной точки в лабиринте.

    Args:
        maze (list[list[int]]): 2D список, представляющий лабиринт (0 - путь, 1 - стена).
        start (tuple[int, int]): Кортеж (строка, столбец) начальной точки.
        end (tuple[int, int]): Кортеж (строка, столбец) конечной точки.

    Returns:
        list[list[tuple[int, int]]]: Список всех найденных путей.
                                     Каждый путь - это список кортежей (строка, столбец).
    """
    all_paths = [] # Здесь будут храниться все найденные пути
    
    # Вспомогательная рекурсивная функция для поиска путей
    # (r, c) - текущая позиция
    # current_path - список точек, пройденных в текущем пути
    # visited - набор точек, посещенных в ТЕКУЩЕМ пути (для избежания циклов)
    def backtrack(r, c, current_path, visited):
        # Базовые проверки:
        # 1. Выход за границы лабиринта
        if not (0 <= r < MAZE_SIZE and 0 <= c < MAZE_SIZE):
            return
        # 2. Попадание в стену
        if maze[r][c] == 1:
            return
        # 3. Повторное посещение клетки в текущем пути (избегаем циклов)
        if (r, c) in visited:
            return

        # Добавляем текущую клетку к пути и помечаем как посещенную
        current_path.append((r, c))
        visited.add((r, c))

        # Базовый случай: Достигли конечной точки
        if (r, c) == end:
            # Найден полный путь, добавляем его КОПИЮ в список всех путей
            all_paths.append(list(current_path))
            
            # ВАЖНО: После нахождения пути нужно откатиться,
            # чтобы найти другие возможные пути, ведущие к этому же концу
            # или продолжающиеся из этой же точки, но по другим маршрутам.
            visited.remove((r, c))
            current_path.pop()
            return

        # Рекурсивный шаг: Исследуем соседние клетки (вверх, вниз, влево, вправо)
        #                 dr, dc: изменения в строке и столбце
        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] # (вправо, вниз, влево, вверх)
        for dr, dc in moves:
            next_r, next_c = r + dr, c + dc
            backtrack(next_r, next_c, current_path, visited)

        # Откат (backtrack): Удаляем текущую клетку из пути и из "посещенных"
        # Это позволяет исследовать другие маршруты, проходящие через эту клетку.
        visited.remove((r, c))
        current_path.pop()

    # Начальный вызов рекурсивной функции
    # Проверка на случай, если старт или конец на стене
    if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:
        print("Начальная или конечная точка находится в стене.")
        return []

    backtrack(start[0], start[1], [], set())
    return all_paths

# --- Запуск программы ---
paths = find_all_paths_in_maze(MAZE, START_POINT, END_POINT)

if paths:
    print(f"Найдено {len(paths)} путей из {START_POINT} в {END_POINT}:")
    for i, path in enumerate(paths):
        print(f"Путь {i+1}: {path}")
else:
    print(f"Пути из {START_POINT} в {END_POINT} не найдены.")

# Пример для лабиринта без путей
MAZE_NO_PATH = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 0, 0, 0]
]
print("n--- Проверка для лабиринта без пути ---")
paths_no_path = find_all_paths_in_maze(MAZE_NO_PATH, (0,0), (4,4))
if paths_no_path:
    print(f"Найдено {len(paths_no_path)} путей.")
else:
    print("Пути не найдены в лабиринте без пути.")
